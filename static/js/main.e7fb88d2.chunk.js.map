{"version":3,"sources":["Scene.jsx","App.js","serviceWorker.js","index.js"],"names":["Scene","props","start","bind","stop","animate","document","title","width","this","mount","clientWidth","height","clientHeight","scene","THREE","camera","position","set","lookAt","renderer","antialias","setClearColor","setSize","GLTFLoader","load","gltf","onModelLoaded","undefined","error","console","light","add","light2","appendChild","domElement","orbitControl","OrbitControls","zoomSpeed","stats","Stats","body","dom","window","addEventListener","onWindowResize","aspect","innerWidth","innerHeight","updateProjectionMatrix","makeArray","rows","cols","model","scale","cnt","i","j","instance","clone","x","z","zGap","animateModel","rot6","Math","PI","randomDue","random","createjs","get","loop","wait","to","y","backInOut","rotation","removeChild","frameId","requestAnimationFrame","cancelAnimationFrame","begin","renderScene","end","update","render","style","overflow","ref","React","Component","App","className","Boolean","location","hostname","match","ReactDOM","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.e7fb88d2.chunk.js","sourcesContent":["import React from 'react'\r\nimport * as THREE from 'three'\r\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\nimport Stats from 'stats-js';\r\nimport * as createjs from 'createjs-module';\r\n\r\nclass Scene extends React.Component {\r\n    constructor(props) {\r\n        super(props)\r\n\r\n        this.start = this.start.bind(this)\r\n        this.stop = this.stop.bind(this)\r\n        this.animate = this.animate.bind(this)\r\n    }\r\n\r\n    componentDidMount() {\r\n        // set title\r\n        document.title = \"Threejs demo\"\r\n        const width = this.mount.clientWidth\r\n        const height = this.mount.clientHeight\r\n\r\n        const scene = new THREE.Scene()\r\n        const camera = new THREE.PerspectiveCamera(\r\n            22,\r\n            width / height,\r\n            0.01,\r\n            1000\r\n        )\r\n        camera.position.set(-40, 10, 20);\r\n        camera.lookAt(0, -5, 0);\r\n\r\n\r\n        const renderer = new THREE.WebGLRenderer({ antialias: true })\r\n\r\n        // set background color\r\n        renderer.setClearColor('#bbbbbb', 1)\r\n        renderer.setSize(width, height)\r\n\r\n        this.scene = scene\r\n        this.camera = camera\r\n        this.renderer = renderer\r\n\r\n        var loader = new GLTFLoader();\r\n        loader.load('nut.glb',\r\n            (gltf) => this.onModelLoaded(gltf),\r\n            undefined,\r\n            function (error) {\r\n                console.error(\"EXCEPTION: \" + error);\r\n            });\r\n\r\n        const light = new THREE.PointLight(0xffffff);\r\n        light.position.set(8, 50, -10);\r\n        this.scene.add(light);\r\n\r\n        const light2 = new THREE.PointLight(0xffeeff);\r\n        light2.position.set(2, 50, 10);\r\n        this.scene.add(light2);\r\n\r\n        this.mount.appendChild(this.renderer.domElement)\r\n        this.start()\r\n\r\n        this.orbitControl = new OrbitControls(camera, renderer.domElement);\r\n        this.orbitControl.zoomSpeed = 5.0;\r\n\r\n        this.stats = new Stats();\r\n        document.body.appendChild(this.stats.dom);\r\n        \r\n        window.addEventListener('resize', () => this.onWindowResize(), false);\r\n    }\r\n\r\n\r\n    onWindowResize() {\r\n        this.camera.aspect = window.innerWidth / window.innerHeight;\r\n        this.camera.updateProjectionMatrix();\r\n        this.renderer.setSize(window.innerWidth, window.innerHeight);\r\n    }\r\n\r\n    onModelLoaded(gltf) {\r\n        this.makeArray(20, 20, gltf.scene)\r\n    }\r\n\r\n    makeArray(rows, cols, model) {\r\n        model.scale.set(1, 1, 1);\r\n        const xGap = 2;\r\n        const zGap = 2.55;\r\n        let cnt = 0;\r\n        for (let i = 0; i < rows; i++) {\r\n            for (let j = 0; j < cols; j++) {\r\n\r\n                let instance = model.clone();\r\n                instance.position.x = -(xGap * cols) / 2 + j * xGap\r\n                instance.position.z = -(zGap * rows) / 2 + i * zGap + (j % 2 === 0 ? zGap / 2 : 0);\r\n\r\n                // animaty every other one \r\n                if ((cnt++ + i) % 2 === 0) {\r\n                    this.animateModel(instance);\r\n                }\r\n                this.scene.add(instance);\r\n            }\r\n        }\r\n    }\r\n\r\n    animateModel(model) {\r\n        // full, half, quarter, sixth\r\n        const fRot = Math.PI * 2;\r\n       // const hRot = Math.PI;\r\n        //const qRot = hRot / 2;\r\n        const rot6 = fRot / 6;\r\n        const jumpHeight = 4;\r\n\r\n        const randomDue = Math.random() * 1000;\r\n\r\n        const dir = 1;//Math.random() >0.5 ? 1 : -1;\r\n        \r\n        // position\r\n        createjs.Tween.get(model.position, { loop: true })\r\n            .wait(randomDue)\r\n            .to({ y: model.position.y + jumpHeight }, 2000, createjs.Ease.backInOut)\r\n            .wait(4000)\r\n            .to({ y: model.position.y }, 2000, createjs.Ease.backInOut)\r\n            .wait(2000 - randomDue);\r\n        \r\n        // animate rotation\r\n        createjs.Tween.get(model.rotation, { loop: true })\r\n            .wait(randomDue)\r\n            .wait(1500)\r\n            .to({ x: 3 * dir * rot6 }, 4000, createjs.Ease.backInOut)\r\n            .wait(2500 - randomDue)\r\n            .wait(2000);\r\n     }\r\n\r\n    componentWillUnmount() {\r\n        this.stop()\r\n        this.mount.removeChild(this.renderer.domElement)\r\n    }\r\n \r\n    start() {\r\n        if (!this.frameId) {\r\n            this.frameId = requestAnimationFrame(this.animate)\r\n        }\r\n    }\r\n\r\n    stop() {\r\n        cancelAnimationFrame(this.frameId)\r\n    }\r\n\r\n    animate() {\r\n        this.stats.begin();\r\n        this.renderScene();\r\n        this.stats.end()\r\n        this.frameId = window.requestAnimationFrame(this.animate)\r\n        this.orbitControl.update();\r\n    }\r\n\r\n    renderScene() {\r\n        this.renderer.render(this.scene, this.camera)\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div\r\n                style={{ width: '100%', height: '100vh', overflow: 'hidden' }}\r\n                ref={(mount) => { this.mount = mount }}\r\n            />\r\n        )\r\n    }\r\n\r\n}\r\n\r\nexport default Scene;","import React from 'react';\nimport Scene from './Scene';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Scene/>  \n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}